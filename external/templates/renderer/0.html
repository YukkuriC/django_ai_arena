{% extends 'renderer/base.html' %}
{% load static %}
{% load main_filters %}

{% block css %}
{{ block.super }}
<style>
    #main {
        display: grid;
        grid-template-columns: repeat(3, 150px);
        grid-template-rows: repeat(3, 150px);
        background-color: #ddd;
        width: 450px;
        height: 450px;
        margin: auto;
    }

    .node {
        width: 130px;
        height: 130px;
        margin: 10px;
        font-size: 75px;
        font-weight: bolder;
        text-align: center;
        display: flex;
        align-items: center;
        border-radius: 5px;
        transition: 0.1s all;
    }

    .occupied {
        box-shadow: gray 0px 5px 10px;
    }

    .node p {
        margin: auto;
        text-align: center;
    }

    .grouped {
        box-shadow: 0px 0px 15px gold !important;
    }

    .curr {
        box-shadow: 0px 0px 15px red !important;
    }

    #chart {
        transition: 0.5s all;
    }

    .stickpool {
        width: 450px;
    }

    .stickpool>div {
        background-color: #ddd;
        margin: 2px 0;
    }

    .stickpool>div>div {
        border: 1px solid black;
        height: 30px;
        border-radius: 5px;
        display: inline-block;
        text-align: center;
    }
</style>
{% endblock %}

{% block descriptions %}
<div class='row x_block'>
    <div class='col-sm-1' id='d_turn'>回合</div>
    <div class='col-sm-5' id='d_action'>动作</div>
    <div class='col-sm-6' id='widget_group'>
        <input type="color" id='clr1' title='先手颜色'>
        <input type="color" id='clr2' title='后手颜色'>
    </div>
</div>
<div id="chart"></div>
{% endblock %}

{% block display_body %}
<div class='col-sm-6'>
    <div id="main">
    </div>
</div>
<div class='col-sm-6' id='stick_main'>
    <h4>先手占优</h4>
    <div class='stickpool' id='pool_0'>
    </div>
    <h4>后手占优</h4>
    <div class='stickpool' id='pool_1'>
    </div>
    <h4>其它组合</h4>
    <div class='stickpool' id='pool_null'>
    </div>
</div>
{% endblock %}

{% block script %}
{{ block.super }}
<script>
    class StickPool {
        constructor() {
        }
    }
    // sticks
    var pool_0 = document.getElementById('pool_0'),
        pool_1 = document.getElementById('pool_1'),
        pool_null = document.getElementById('pool_null'),
        pool_root = document.getElementById('stick_main')
    sticks = []
    function init_sticks() {
        for (var i = 1; i <= 7; i++) {
            for (var j = i + 1; j <= 8; j++) {
                for (var k = j + 1; k <= 9; k++) {
                    if (i + j + k == 15) {
                        var stick = document.createElement('div')
                        stick.id = `stick_${i}${j}${k}`
                        stick.values = [i, j, k]
                        for (var val of stick.values) {
                            var piece = document.createElement('div')
                            piece.innerHTML = val
                            Object.assign(piece.style, {
                                width: (30 * val) + 'px',
                                backgroundColor: `var(--clr_${val})`,
                                color: `var(--clr_inv_${val})`
                            })
                            stick.appendChild(piece)
                        }
                        pool_null.appendChild(stick)
                        sticks.push(stick)
                    }
                }
            }
        }
    }
    function refresh_sticks(orders) {
        for (var i = 1; i <= 9; i++) {
            pool_root.style.removeProperty(`--clr_${i}`)
            pool_root.style.removeProperty(`--clr_inv_${i}`)
        }
        orders.forEach((nums, pid) => {
            for (var i of nums) {
                pool_root.style.setProperty(`--clr_${i}`, COLORS[pid])
                pool_root.style.setProperty(`--clr_inv_${i}`, is_dark(COLORS[pid]))
            }
        })
        sticks.forEach(e => {
            e.parentNode.removeChild(e)
            var is_0 = false,
                is_1 = false,
                filled = 0
            for (var val of e.values) {
                if (orders[0].includes(val)) {
                    is_0 = true
                    filled++
                }
                else if (orders[1].includes(val)) {
                    is_1 = true
                    filled++
                }
            }
            e.classList.remove('grouped')
            if (is_0 == is_1) pool_null.appendChild(e)
            else {
                (is_0 ? pool_0 : pool_1).appendChild(e)
                if (filled == 3) e.classList.add('grouped')
            }
        })
    }

    REMAPPER = {
        '0,0': 8, '0,1': 1, '0,2': 6,
        '1,0': 3, '1,1': 5, '1,2': 7,
        '2,0': 4, '2,1': 9, '2,2': 2,
    }

    // 判断某颜色为深色或浅色
    function is_dark(clr) {
        var clr_num = 1 * clr.replace('#', '0x'),
            b = clr_num & 255,
            g = (clr_num >> 8) & 255,
            r = (clr_num >> 16) & 255

        return (r + g + b < 382.5) ? 'white' : 'black'
    }

    // 变量配置
    function init() {
        TOTAL_FRAMES = record_obj.orders.length
        PLAYING_FPS = 1
        // 创建棋盘
        var main = document.getElementById('main')
        for (var c = 0; c < 3; c++) {
            for (var r = 0; r < 3; r++) {
                var node = document.createElement('div')
                var key = [r, c] + '',
                    ind = REMAPPER[key]
                var xr = Math.floor((ind - 1) / 3) + 1,
                    xc = (ind - 1) % 3 + 1
                Object.assign(node, {
                    id: `tile${key}`,
                    className: 'node',
                    style: `grid-column: ${xc};grid-row: ${xr};`,
                    innerHTML: `<p>${ind}</p>`,
                })
                main.appendChild(node)
            }
        }

        // 复原棋盘
        var board = { orders: [[], []] }
        record_obj.orders.forEach((pos, i) => {
            let key = pos + ''
            board[key] = i % 2
            board.orders[i % 2].push(REMAPPER[key])
            board_copy = {}
            for (let key in board) board_copy[key] = board[key]
            board_copy.curr = key
            board_copy.orders = board.orders.map(x => Array.from(x))
            FRAMES.push(board_copy)
        })
        if (record_obj.reason <= -3) {
            FRAMES.push(board)
            TOTAL_FRAMES++
        }

        // 配置控件
        init_widgets()
        init_sticks()
    }

    FRAMES = []
    COLORS = ['#ffffff', '#000000']
    WIDGETS = {} // 存放颜色控件

    // 控件
    function init_widgets() {
        // 添加引用
        for (var x of document.getElementById('widget_group').children) {
            WIDGETS[x.id] = x
        }

        // 颜色配置
        for (var i = 0; i < 2; i++) {
            var widget = WIDGETS['clr' + (i + 1)]
            bind_color(widget, i)
        }
    }
    function bind_color(widget, ind) {
        widget.value = COLORS[ind]
        widget.addEventListener('change', e => {
            COLORS[ind] = widget.value
            draw_frame()
        })
    }

    // 更新描述
    var descrips = [
        document.getElementById('d_turn'),
        document.getElementById('d_action'),
    ]
    function update_descrip(frame, index) {
        descrips[0].innerHTML = `#${index}`
        descrips[1].innerHTML = `${'先后'[index % 2]}手玩家选取数字${REMAPPER[frame.curr]}`
    }

    // 更新棋盘
    function update_board(data) { // 显示指定棋盘内容
        console.log(data)
        for (var r = 0; r < 3; r++) {
            for (var c = 0; c < 3; c++) {
                var key = [r, c] + ''
                var cell = document.getElementById(`tile${key}`),
                    num = data[key]
                var is_occupied = (num !== undefined),
                    is_plr0 = is_occupied ? (num > 0) : (c < 4),
                    is_curr = (key == data.curr)

                // 更新样式
                if (is_occupied) {
                    cell.style.backgroundColor = COLORS[num]
                    cell.classList.add('occupied')
                    cell.style.color = is_dark(COLORS[num])
                } else {
                    cell.style.backgroundColor = 'transparent'
                    cell.classList.remove('occupied')
                    cell.style.color = 'green'
                }
                with (cell.classList) {
                    remove('grouped')
                    if (is_curr) add('curr')
                    else remove('curr')
                }
            }
        }
    }

    // 更新结果显示
    LOOPER = [0, 1, 2]
    CHECKERS = []
    LOOPER.forEach(x => {
        CHECKERS.push(LOOPER.map(y => [x, y] + ''))
        CHECKERS.push(LOOPER.map(y => [y, x] + ''))
    })
    CHECKERS.push(LOOPER.map(x => [x, x] + ''))
    CHECKERS.push(LOOPER.map(x => [x, 2 - x] + ''))
    function update_ending(frame, index) {
        if (index < TOTAL_FRAMES - 1) return
        for (const line of CHECKERS) {
            values = line.map(p => frame[p])
            if (!(values[0] !== undefined && values[1] == values[0] && values[2] == values[0])) continue
            // 标记单行
            line.forEach(pos => {
                if (pos == frame.curr) return
                var cell = document.getElementById(`tile${pos}`)
                cell.classList.add('grouped')
            })
        }

        switch (record_obj.reason) {
            case -4:
                descrips[1].innerText = `${'先后'[index % 2]}手玩家代码超时落败`
                break
            case -3:
                descrips[1].innerText = `${'先后'[index % 2]}手玩家代码报错: ${record_obj.extra}`
                break
            case -2:
                descrips[1].innerText = `${'先后'[index % 2]}手玩家冲突选数: ${frame.curr}`
                break
            case -1:
                descrips[1].innerText = `${'先后'[index % 2]}手玩家返回非法取值`
                break
        }
        switch (record_obj.reason) {
            case -4:
            case -3:
            case -2:
            case -1:
                descrips[1].innerText += `，${'先后'[(index + 1) % 2]}手玩家获胜`
                break
            case 1:
                descrips[1].innerText += '，获得15组合获胜'
                break
            case 2:
                descrips[1].innerText += '，填满棋盘平局'
                break
        }
    }

    // 绘制接口
    function draw_frame(index = CURR_FRAME) {
        frame = FRAMES[index]
        if (!frame) return
        update_board(frame)
        update_descrip(frame, index)
        update_ending(frame, index)
        refresh_sticks(frame.orders)
    }
</script>
{% endblock %}